(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{406:function(s,e,t){"use strict";t.r(e);var a=t(4),r=Object(a.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"kubernetes-健康检查介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-健康检查介绍"}},[s._v("#")]),s._v(" Kubernetes 健康检查介绍")]),s._v(" "),e("p",[s._v("K8S 支持三种健康检查：")]),s._v(" "),e("ol",[e("li",[s._v("就绪检查("),e("code",[s._v("readinessProbe")]),s._v("): Pod启动后，如果配了就绪检查，要等就绪检查探测成功，Pod Ready 状态变为 True，允许放流量进来；在运行期间如果突然探测失败，Ready 状态变为 False，摘除流量。")]),s._v(" "),e("li",[s._v("存活检查("),e("code",[s._v("livenessProbe")]),s._v("): Pod 在运行时，如果存活检查探测失败，会自动重启容器；值得注意的是，存活探测的结果不影响 Pod 的 Ready 状态，这也是许多同学可能误解的地方。")]),s._v(" "),e("li",[s._v("启动检查("),e("code",[s._v("startupProbe")]),s._v("): 作用是让存活检查和就绪检查的开始探测时间延后，等启动检查成功后再开始探测，通常用于避免业务进程启动慢导致存活检查失败而被无限重启。")])]),s._v(" "),e("div",{staticClass:"language-yaml line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[e("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("readinessProbe")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("successThreshold")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 1 次探测成功就认为健康")]),s._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("failureThreshold")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 连续 2 次探测失败认为不健康")]),s._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("periodSeconds")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 3s 探测一次")]),s._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("timeoutSeconds")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 2s 超时还没返回成功就认为不健康")]),s._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("httpGet")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v('# 使用 http 接口方式探测，GET 请求 80 端口的 "/healthz" 这个 http 接口，响应状态码在200~399之间视为健康，否则不健康。')]),s._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("port")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("80")]),s._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("path")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v('"/healthz"')]),s._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v('#exec: # 使用脚本探测，执行容器内 "/check-health.sh" 这个脚本文件，退出状态码等于0视为健康，否则不健康。')]),s._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v('#  command: ["/check-health.sh"]')]),s._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#tcp: # 使用 TCP 探测，看 9000 端口是否监听。")]),s._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#  port: 9000")]),s._v("\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br")])]),e("h2",{attrs:{id:"探测结果一定要真实反应业务健康状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#探测结果一定要真实反应业务健康状态"}},[s._v("#")]),s._v(" 探测结果一定要真实反应业务健康状态")]),s._v(" "),e("h3",{attrs:{id:"首选-http-探测"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#首选-http-探测"}},[s._v("#")]),s._v(" 首选 HTTP 探测")]),s._v(" "),e("p",[s._v("通常是推荐业务自身提供 http 探测接口，如果业务层面健康就返回 200 状态码；否则，就返回 500。")]),s._v(" "),e("h3",{attrs:{id:"备选脚本探测"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#备选脚本探测"}},[s._v("#")]),s._v(" 备选脚本探测")]),s._v(" "),e("p",[s._v("如果业务还不支持 http 探测接口，或者有探测接口但不是 http 协议，也可以将探测逻辑写到脚本文件里，然后配置脚本方式探测。")]),s._v(" "),e("h3",{attrs:{id:"尽量避免-tcp-探测"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#尽量避免-tcp-探测"}},[s._v("#")]),s._v(" 尽量避免 TCP 探测")]),s._v(" "),e("p",[s._v("另外，应尽量避免使用 TCP 探测，因为 TCP 探测实际就是 kubelet 向指定端口发送 TCP SYN 握手包，当端口被监听内核就会直接响应 ACK，探测就会成功；当程序死锁或 hang 死，这些并不影响端口监听，所以探测结果还是健康，流量打到表面健康但实际不健康的 Pod 上，就无法处理请求，从而引发业务故障。")]),s._v(" "),e("h2",{attrs:{id:"所有提供服务的-container-都要加上-readinessprobe"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#所有提供服务的-container-都要加上-readinessprobe"}},[s._v("#")]),s._v(" 所有提供服务的 container 都要加上 ReadinessProbe")]),s._v(" "),e("p",[s._v("如果你的容器对外提供了服务，监听了端口，那么都应该配上 ReadinessProbe，ReadinessProbe 不通过就视为 Pod 不健康，然后会自动将不健康的 Pod 踢出去，避免将业务流量转发给异常 Pod。")]),s._v(" "),e("h2",{attrs:{id:"谨慎使用-livenessprobe"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#谨慎使用-livenessprobe"}},[s._v("#")]),s._v(" 谨慎使用 LivenessProbe")]),s._v(" "),e("p",[s._v("LivenessProbe 失败会重启 Pod，不要轻易使用，除非你了解后果并且明白为什么你需要它，参考 "),e("a",{attrs:{href:"https://srcco.de/posts/kubernetes-liveness-probes-are-dangerous.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("Liveness Probes are Dangerous"),e("OutboundLink")],1),s._v(" 。")]),s._v(" "),e("h3",{attrs:{id:"探测条件要更宽松"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#探测条件要更宽松"}},[s._v("#")]),s._v(" 探测条件要更宽松")]),s._v(" "),e("p",[s._v("如果使用 LivenessProbe，不要和 ReadinessProbe 设置成一样，需要更宽松一点，避免因抖动导致 Pod 频繁被重启。")]),s._v(" "),e("p",[s._v("通常是失败阈值 ("),e("code",[s._v("failureThreshold")]),s._v(") 设置得更大一点，避免因探测太敏感导致 Pod 很容易被重启。")]),s._v(" "),e("p",[s._v("另外如果有必要，超时时间 ("),e("code",[s._v("timeoutSeconds")]),s._v(") 和探测间隔 ("),e("code",[s._v("periodSeconds")]),s._v(") 也可以根据情况适当延长。")]),s._v(" "),e("h3",{attrs:{id:"保护慢启动容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#保护慢启动容器"}},[s._v("#")]),s._v(" 保护慢启动容器")]),s._v(" "),e("p",[s._v("有些应用本身可能启动慢(比如 Java)，或者用的富容器，需要起一大堆依赖，导致容器启动需要的较长，如果配置了存活检查，可能会造成启动过程中达到失败阈值被重启，如此循环，无限重启。")]),s._v(" "),e("p",[s._v("对于这类启动慢的容器，我们需要保护下，等待应用完全启动后才开始探测:")]),s._v(" "),e("ol",[e("li",[s._v("如果 K8S 版本低于 1.18，可以设置 LivenessProbe 的初始探测延时 ("),e("code",[s._v("initialDelaySeconds")]),s._v(")。")]),s._v(" "),e("li",[s._v("如果 K8S 版本在 1.18 及其以上，可以配置 "),e("a",{attrs:{href:"https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes",target:"_blank",rel:"noopener noreferrer"}},[s._v("StartProbe"),e("OutboundLink")],1),s._v("，保证等应用完全启动后才开始探测。")])]),s._v(" "),e("h3",{attrs:{id:"避免依赖导致级联故障"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#避免依赖导致级联故障"}},[s._v("#")]),s._v(" 避免依赖导致级联故障")]),s._v(" "),e("p",[s._v("LivenessProbe 探测逻辑里不要有外部依赖 (db, 其它 pod 等)，避免抖动导致级联故障。")]),s._v(" "),e("p",[s._v("如Pod B 探测逻辑里查 DB，Pod A 探测逻辑里调用 Pod B，如果 DB 抖动，Pod B 变为不健康，Pod A 调用 Pod B 也失败，也变为不健康，从而级联故障。")])])}),[],!1,null,null,null);e.default=r.exports}}]);